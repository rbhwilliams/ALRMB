#--functions for Another Long Read Metagenome Binner (ALRMB)
#--based on Yuguang Ipsen's original script from her Singapore visit in Jan 2019
#--updated and modified by Rohan Williams on and off since then.

#--need these


#--calculate GC content
calculate.gc<-function(contigs)
{
 contigs.1merMat<-Biostrings::oligonucleotideFrequency(contigs,1)
 gc<-rowSums(contigs.1merMat[,c("G","C")])/rowSums(contigs.1merMat)
 names(gc)<-names(contigs)
 return(gc)
}

get.contig.metadata<-function(contigs)
{
 #--here, we are just grabbing length and GC...coverage needs an external calculation
 #--further columns get added to this downstream
 res<-data.frame(gc=calculate.gc(contigs),len=nchar(contigs),row.names=names(contigs))
 return(res)
}

generate.kmer.frequency.matrix<-function(contigs,k)
{
 #--'contigs' is a DNAstringSet object
 #--'k' is an interger which selects which k-mer frequency
 #--generate a compositional matrix from the (signature frequencies, sensu Gori)
 require(kmer,ape)
 contigsDNABin<-as.DNAbin(contigs)
 kmerFreqMat<-kcount(contigsDNABin,k=k,residues="DNA")
 return(kmerFreqMat)
 }

convert.kmer.frequency.to.composition<-function(kmerFreqMat)
{
 #--'kmerFreqMat' is a k-mer frequency martrix generated by 'generate.kmer.frequency.matrix'
 #--row-normalise and take square root to obtain a compositional version,
 #--the matrix gives each contig (rows) projected on the non-negative orthant of an S^(4^k-1) hyposphere (for 4 nucleotides)
 require(analogue)
 kmerFreqMat.rn<-kmerFreqMat/rowSums(kmerFreqMat)
 kmerCompMat<-sqrt(kmerFreqMat.rn)
 return(kmerCompMat)
}

get.great.circle.dmat<-function(kmerCompMat)
{
 #--'kmerCompMat' is a compositional matrix, generated from 'convert.kmer.frequency.to.composition' which can contain zeroes
 #--self-self distances (on the diagonal) are set to zero, the warning message comes from those
 ipm<-kmerCompMat%*%t(kmerCompMat)
 dmat<-acos(ipm)
 diag(dmat)<-0
 return(dmat)
}

make.tsne<-function(dmat,...)
{
 #--trivial, but we need to add rownames to the tnse output matrix!
 res<-tsne(dmat,...)
 rownames(res)<-rownames(dmat)
 colnames(res)<-c("Axis1","Axis2")
 return(res)
}

make.primary.clusters<-function(tsneRes,eps,minpts,metadata)
{
 pcRes<-dbscan(tsneRes,eps=eps,minPts=minpts)
 res<-data.frame(metadata[rownames(tsneRes),],tsneRes,pc.id=pcRes$cluster,stringsAsFactors=F)
 return(res)
}

#--add coverage (add coverage to the metadata)
add.coverage<-function(metadata,namedCoverageVec)
{
 #--for now, namedCoverageVec is a vector of coverage values, named by contig
 #--align with metadata rows and add a new column named cov and lgcov
 res<-metadata
 res$cov<-namedCoverageVec[rownames(metadata)]
 res$lgcov<-log10(res$cov)
 return(res)
}
 
make.secondary.clusters<-function(covAugMetadata,covtype=c("cov","lgcov"))
{
 #--we are removing singletons before proceeding
 res<-subset(covAugMetadata,pc.id!=0)
 #--and any primary clusters that only contain a single contig
 contigsPerPC<-table(res$pc.id)
 pcToUse<-names(contigsPerPC)[which(contigsPerPC>=2)]
 res1<-res[res$pc.id%in%pcToUse,]
 
 #--convert to a list whose element contain the contigs in each primary cluster
 scCol<-rep("",nrow(res1))
 names(scCol)<-rownames(res1)
 pc2contigsList<-tapply(rownames(res1),INDEX=res1$pc.id,FUN=function(x){x})
 for(curpc in (1:length(pc2contigsList)))
 {
  curtag<-names(pc2contigsList)[curpc]
  print(curtag)
  curcontigs<-pc2contigsList[[curtag]]
  curpccov<-as.matrix(res1[curcontigs,covtype])
  curres<-Ckmedian.1d.dp(curpccov,k=c(1,nrow(curpccov)))$cluster
  names(curres)<-curcontigs
  curout<-tapply(names(curres),INDEX=curres,FUN=function(x){x})
  names(curout)<-paste(curtag,names(curout),sep="_")
  for(cursc in names(curout))
  {
   scCol[curout[[cursc]]]<-cursc
  }
 }
 res1$sc.id<-scCol
 return(res1)
}

#--Rohan finished editing here on 03 November 2022--
